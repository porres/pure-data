#N canvas 330 65 987 633 12;
#X obj 60 320 soundfiler;
#X floatatom 60 349 7 0 0 0 - - - 12;
#X obj 371 588 tabwrite~;
#X obj 445 588 tabread4~;
#X obj 518 588 tabplay~;
#X obj 304 588 writesf~;
#X obj 246 588 readsf~;
#X text 14 589 See also:;
#X obj 40 15 soundfiler;
#X obj 195 588 array;
#X listbox 127 349 16 0 0 0 - - - 0;
#X obj 6 47 cnv 1 975 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 876 14 <= click;
#N canvas 540 87 632 371 reference 0;
#X obj 8 52 cnv 5 610 5 empty empty INLET: 8 18 0 13 #202020 #000000 0;
#X obj 8 182 cnv 2 610 2 empty empty OUTLETS: 8 12 0 13 #202020 #000000 0;
#X obj 8 301 cnv 2 610 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 7 335 cnv 5 610 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X obj 7 247 cnv 1 610 1 empty empty 2nd: 8 12 0 13 #7c7c7c #000000 0;
#X obj 7 210 cnv 1 610 1 empty empty 1st: 8 12 0 13 #7c7c7c #000000 0;
#X text 109 254 list -;
#X text 102 219 float - number of samples (when reading a file)., f 58;
#X text 75 66 read <list> -;
#X text 174 66 sets a filename to open and optionally one or more arrays to load channels. Optional flags: -wave \, -aiff \, -caf \, -next \, -skip <float> \, -maxsize <float> \, -ascii \, -raw <list>.;
#X text 68 117 write <list> -;
#X obj 30 15 soundfiler;
#X text 234 309 NONE;
#X text 174 116 sets a filename to write and one or more arrays to specify channels. Optional flags: -wave \, -aiff \, -caf \, -ascii \, -next \, -big \, -little \, -skip <float> \, -nframes <float> \, -normalize \, -rate <float>.;
#X text 157 254 sample rate \, header size \, number of channels \, bytes per sample & endianness ('b' or 'l')., f 51;
#X text 112 15 - import/export sound or ascii files to/from arrays.;
#X restore 782 15 pd reference;
#X msg 61 184 read ../sound/bell.aiff sample;
#X msg 87 215 read -resize ../sound/bell.aiff sample;
#X text 367 208 optionally resize array to fit the whole file, f 23;
#X text 28 127 Basic read/write example:;
#N canvas 762 180 575 345 Dealing_with_"\$0" 0;
#X obj 273 171 array define \$0-x;
#X obj 153 202 f \$0;
#X obj 153 263 soundfiler;
#X floatatom 153 289 7 0 0 0 - - - 0;
#X msg 153 231 read -resize ../sound/bell.aiff \$1-x;
#X obj 153 176 loadbang;
#X text 405 172 <- array with local name, f 13;
#X text 36 33 '\$0' - the patch ID number used to force locality in Pd - is widely used in send/receive names as well as array names. This is especially useful in abstractions so each copy has local names instead of global., f 70;
#X text 36 86 Here we use "\$0" in an array name in [array define] and if you need to set the array name in a message you can load '\$0' in a float object and send it to it., f 70;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 4 0 2 0;
#X connect 5 0 1 0;
#X restore 752 375 pd Dealing_with_"\$0";
#X obj 586 588 openpanel;
#X obj 659 588 savepanel;
#X text 44 369 # samples;
#X text 96 259 write to a file;
#X text 124 369 info: sample rate \, header size \, channels \, bytes \, endianness;
#X obj 286 261 cnv 19 248 98 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 22 450 300 (subpatch) 0;
#X array sample 50000 float 2;
#A color 0;
#A width 2;
#X coords 0 1 50000 -1 250 100 1 0 0;
#X restore 285 260 graph;
#X text 593 348 Open subpatch to see how to deal with '\$0';
#X msg 93 284 write ~/test.wav sample;
#N canvas 66 180 1200 556 read-write-flags 0;
#X obj 632 456 soundfiler;
#X text 25 13 Flags for 'read' message:, f 73;
#X text 16 380 Flags for 'write' message:, f 69;
#X text 46 215 [soundfiler] can figure out which of the known soundfile formats the file belongs to or override all header and type information using the "-raw" flag \, which causes all header and type information to be ignored. Endianness is "l" ("little") for Intel machines or "b" ("big") for older PPC Macintoshes. You can give "n" (natural) to take the byte order your machine prefers., f 70;
#X text 25 33 -wave \, -aiff \, -caf \, -next (soundfile format), f 73;
#X text 894 168 read from an ascii file;
#X listbox 699 494 17 0 0 0 - - - 0;
#X msg 615 141 read -resize -raw 128 2 2 b ../sound/bell.aiff array1 array2;
#X msg 641 196 read -ascii -resize table.txt array1 array2;
#X floatatom 632 494 6 0 0 0 - - - 0;
#X obj 572 49 openpanel;
#X obj 572 19 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 660 294 savepanel;
#X obj 660 259 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X text 16 488 -rate <float> (sample rate \, default Pd's running sample rate), f 71;
#X text 16 434 -skip <float> (number of points to skip in array \, default 0), f 69;
#X text 25 50 -skip <float> (sample frames to skip in the file as an offset), f 73;
#X text 25 193 -raw <f \, f \, f \, s> (header size \, channels \, bytes per sample \, endianness), f 73;
#X text 16 400 -wave \, -aiff \, -caf \, -next \, -ascii (soundfile format \, default: 'wave'), f 69;
#X text 16 417 -big \, -little (sample endianness \, default 'little'), f 69;
#X msg 572 78 read -resize \$1 array1 array2;
#X msg 632 168 read -ascii -resize table.txt array1;
#X text 686 261 Write a stereo fie;
#X obj 852 242 cnv 19 323 118 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#X obj 852 386 cnv 19 323 118 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 22 450 300 (subpatch) 0;
#X array array1 87741 float 2;
#A color 0;
#A width 2;
#X coords 0 1 87741 -1 325 120 1 0 0;
#X restore 851 241 graph;
#N canvas 0 22 450 300 (subpatch) 0;
#X array array2 87741 float 2;
#A color 0;
#A width 2;
#X coords 0 1 87741 -1 325 120 1 0 0;
#X restore 851 385 graph;
#N canvas 460 493 480 224 8-byte 0;
#X text 19 62 The precision of the 8-byte samples is based on the precision of the Pure Data build. If Pd is single precision (using 32-bit float internally) \, the written samples will be cast from 4-byte float to 8-byte double when writing to a file with -bytes 8 argument. In this case it's better to write with 4-byte float samples for a smaller file with the same precision., f 63;
#X text 19 159 if Pd is double-precision \, writing 8-byte float samples will be full precision as Pd uses 64-bit float internally., f 63;
#X text 19 19 Writing 8-byte (ie. 64-bit) floating point samples are supported for the .wave \, .aiff/.aifc and .caf file types.;
#X restore 441 470 pd 8-byte float;
#X text 16 506 -normalize (normalize file to '1' \, note that arrays whose values exceed the -1 to 1 range are automatically normalized), f 71;
#X text 614 519 # samples;
#X text 699 520 info: sample rate \, header size \, channels \, bytes \, endianness;
#X text 1048 134 read overriding the file's header, f 17;
#X text 16 451 -nframes <float> (maximum points to write \, default from skip point to end of array), f 83;
#X text 16 469 -bytes <float> (bytes per sample: 2 \, 3 \, 4 \, or 8 default: 2);
#X text 599 20 Choose file to read from;
#N canvas 683 221 473 479 more-write-examples 0;
#X obj 41 442 outlet;
#X text 148 166 write a mono file and set number of samples, f 22;
#X obj 69 177 savepanel;
#X obj 69 142 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 41 69 savepanel;
#X obj 41 34 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 99 278 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X msg 41 104 write -next -bytes 2 \$1 array1 array2;
#X obj 99 319 savepanel;
#X msg 99 355 write -nframes 3 -skip 2 -ascii \$1 array1;
#X msg 69 212 write -skip 22050 -nframes 48000 \$1 array1;
#X text 120 29 write a stereo file with a 2 byte resolution and in the 'next' format (so when typing into the savepannel dialog you should not set the file extension), f 47;
#X text 130 273 write an ascii file ('.txt' extension is automatically added with the ascii flag), f 46;
#X connect 2 0 10 0;
#X connect 3 0 2 0;
#X connect 4 0 7 0;
#X connect 5 0 4 0;
#X connect 6 0 8 0;
#X connect 7 0 0 0;
#X connect 8 0 9 0;
#X connect 9 0 0 0;
#X connect 10 0 0 0;
#X restore 666 377 pd more-write-examples;
#X text 25 302 -ascii (read a file containing ascii numbers), f 73;
#X text 46 319 This may only be combined with '-resize'. Spaces or newlines are valid separators. Non-numeric fields get replaced by zero. For multiple arrays \, data should be interleaved (first elements of each array \, then second elements \, etc). The file must only contain ASCII characters., f 70;
#X text 25 68 -resize (resizes arrays to the sound file's size \, otherwise the extra samples are zeroed out or the array is filled until reaching its size), f 73;
#X text 25 101 -maxsize <float> (Deprecated *) (maximum number of samples to resize to), f 73;
#X text 46 120 * Historically \, the default maximum size used to be only 4 million samples \, so this was needed to increase it and allow loading larger files with -resize. This isn't needed anymore as the current default value is as high as your system can handle., f 70;
#X msg 660 322 write \$1 array1 array2;
#X msg 595 110 read -resize ../sound/stereo.wav array1 array2;
#X connect 0 0 9 0;
#X connect 0 1 6 0;
#X connect 7 0 0 0;
#X connect 8 0 0 0;
#X connect 10 0 20 0;
#X connect 11 0 10 0;
#X connect 12 0 41 0;
#X connect 13 0 12 0;
#X connect 20 0 0 0;
#X connect 21 0 0 0;
#X connect 35 0 0 0;
#X connect 41 0 0 0;
#X connect 42 0 0 0;
#X restore 793 507 pd read-write-flags;
#X text 120 13 - import/export sound or ascii files to/from arrays;
#N canvas 0 22 450 278 (subpatch) 0;
#X array array_x 10 float 3;
#A 0 0 0 0 0 0 0 0 0 0 0;
#A color 0;
#A width 2;
#X coords 0 1 10 -1 90 40 1 0 0;
#X restore 96 578 graph;
#X text 28 61 The [soundfiler] object loads files into arrays and also saves arrays into files. The soundfiles may contain uncompressed 2- or 3-byte integer ("pcm") or 4- or 8-byte floating point samples in wave \, aiff \, caf and next formats. [soundfiler] can also handle ascii text files., f 72;
#X text 579 414 'read' and 'write' messages both support optional flags. In the basic example on the left \, we have the '-resize' flag in the read message that resizes the array to the file size. See more about flags and advanced examples in the subpatch below., f 54;
#X text 578 62 Also note: Loading a soundfile into an array might be useful for more flexible playing strategies with table reading objects in the 'see also' section below. For a simpler alternative that streams a soundfile directly from your hard drive \, see [readsf~]., f 54;
#X text 579 140 When loading or writing a file \, the left outlet outputs the file's number of samples. If you're loading a file that is bigger than the array size \, the number or samples gets clipped to the array size (you probably want to use the -resize flag in this case to automatically resize the array size to the file size)., f 54;
#X text 579 234 The right outlet sends information as a list \, namely: Sample Rate \, Header Size \, Number of Channels \, Bytes per Sample and Endianness: "b" (for "big") or "l" (for "little")., f 54;
#X text 579 299 Important: The number of channels is limited to 64 for both reading and writing., f 54;
#X text 753 587 updated for Pd version 0.56;
#X msg 38 154 read ../sound/voice.wav;
#X text 283 184 read a file to a single array;
#X text 212 153 read a file without arrays (just output data);
#X text 24 495 The 'write' message takes a filename to save to and one or more arrays (one for each channel). Note that both 'read' and 'write' messages can expand "~" to the home directory., f 75;
#X text 24 399 A 'read' message takes a filename and zero or any nymber of arrays to load it into (one for each channel). The number of channels of the soundfile need not match the number of arrays given to read (extras channels are dropped and unsupplied channels are zeroed out in the extra arrays). If you don't supply any array \, no samples are actually read but you still get the output with the file's number of samples and other info., f 75;
#X obj 6 556 cnv 1 975 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X connect 0 0 1 0;
#X connect 0 1 10 0;
#X connect 14 0 0 0;
#X connect 15 0 0 0;
#X connect 27 0 0 0;
#X connect 38 0 0 0;
